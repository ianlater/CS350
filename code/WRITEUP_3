Title: Writeup for Project 3, Fall 2015
Date: 11/8/2015
Group: Name-----------Email
	   John Lucas	  johnluca@usc.edu
	   Ian Later	  later@usc.edu
	   Carrie Sun	  carriesu@usc.edu
	  
I. Requirements
  +Virtual Memory
  	Implement software-management of the TLB
  	Implement virtual memory using TLB, IPT, PT, swapfile, and executable
  +Networking
II. Assumptions
III. Design
	+Virtual Memory
	Keeping consistent with direction from the project guidelines and student documentation, we no longer preload into 
	memory and on page faults begin with a search of IPT, followed by IPT misses which is how the IPT is populated, then
	resorting to page eviction if the freePageBitmap, which we use to keep track of used pages of physical memory, is full.
	We support both random and FIFO eviction poicies which we check in the pageToEvict() function (we've put handlepagefault,
	handleIPTMiss, and handleMemoryFull all in their own functions as well). Our addrspace still alots virtual pages for
	50 threads, but only initializes code, data, and one stack in the constructor. Stack start locations are stored in 
	process tables in exception.cc which correspond to addrspaces and are indexed by threads(their id's). We invalidate the 
	TLB in addrspace::SaveState. In both page faults and tlb modification we disable interrupts to ensure security. 
	+Networking
	In order to have the server own all the locks, condition, and monitor variables, we created a server.cc that runs
	continuously. In its main function, Server(), the server starts waiting to receive a message from any client. Since the
	server's ID is always zero, all clients know who it is. Once it receives a message, it gets the first string out of the data sent,
	and feeds that into a switch statement which will decide what kind of syscall was sent. Each syscall has a doSYSCALL function that takes in
	the relevant information sent along as data from the client, and "does the work" necessary. The syscalls written in exception.cc
	for Project 2 were utilized (by using the NETWORK define) when I added more code to them so that, instead of building a ServerLock or
	something locally, they send their request to the server.
	The general flow of events is as follows: 1. Client userprog requests OS resource. 2. Syscall is handled on client side. 3. since NETWORK define is true, exception syscall builds a message packet with request info, and sends to server. 
	4. on server, request will be received, and the type of request will be the first bytes in the data. 5. knowing the request type, server can do the necessary work(create a lock, signal, monitor variables...) 6. after doing work, server sends back a response (depending on syscall) to either wake thread up, or provide requested information (like lockIndex)
	7. Client received message, and wakes up, and continues
	It is also important to note that the server is single threaded and cannot wait or sleep (other than waiting for a message from a client).
	In order to do waits and lock functions that ensure mutual exclusion, the server takes advantages of the fact that the client that sent a message will
	stay asleep until a reply is given. To do this with locks and conditions, the reply message is put on a wait queue if the resource
	is currently being used. When the resource is released, or a signal occurs, the server sends the message at the top of the wait queue off to its client, which acts
	the same ways as locks and conditions did in project 2. 
IV. Implementation
	+Files Added
		vm/swap
		network/server.cc
		test/netmvtest.c
		test/netclient.c
		test/multilarge.c
	+Files Modified
		threads/main.cc
		threads/system.h
		threads/system.cc
		userprog/addrspace.h
		userprog/addrspace.cc
		userprog/exception.cc
		test/start.s
		userprog/syscall.h
	+Data structures added, and which file to
		server.cc: ServerLock, ServerMonitor, ServerCondition
	+Functions added and in which file
		server.cc: functions for handling each syscall (each Lock, Condition, and Monitor Var function)
			   Server(), the main server function that just runs forever in while loop
			   helper functions in server for testing input, sending messages
		exception.cc: new syscalls for Monitor Vars (Create, Destroy, Get, Set)
			      helper functions for sending and receiving from server
			      handlers for: PageFault, IPTMiss, and MemoryFull
			      pageToEvict for processing FIFO or Random eviction policy
	+Functions modified and in which file
		exception.cc: all syscalls modified for networking
V. Testing
	+Experiment expectation
		all: pagefaults and initial IPT misses that are handled and result in expected behaviors
		lockcondition, fork, exec, locksharing: all behave as in previous projects
		malmult: Exit prints out value of 7220 and requires handling of memoryfull
		sort: Exit prints out value of 1034 and requires handling of memoryfull
		multilarge:  Runs two matmults. Exit prints out value of 7220 two times and requires handling of memoryfull
	+Experiment Result
		all: pagefaults and initial IPT misses that are handled and result in expected behaviors
		lockcondition, fork, exec, locksharing: all behave as in previous projects
		malmult: Exit prints out value of 7220 and requires handling of memoryfull
		sort: Exit prints out value of 1034 and requires handling of memoryfull
		multilarge:  Runs two matmults. Exit prints out value of 7220 two times and requires handling of memoryfull
	+Explanation
		handling of page faults, ipt misses, and memory full works properly. to see statements of this, run w/ args:
		'-d p'. PageFaultException, IPTMiss, and MemoryFull head the appropriate function calls followed be 
		relevant info. If something has already been loaded to IPT, it should say Found in IPT and then give the entry
		and this should not immediately preceed an IPTMiss before the TLB's been written.
VI. Discussion

VIII. Miscellaneous
	Not sure if matmult should fit within numPhysPages of 32, but it required handling of full memory for us.
