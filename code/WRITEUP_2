Title: Writeup for Project 2, Fall 2015
Date: 10/19/2015
Group: Name-----------Email
	   John Lucas	  johnluca@usc.edu
	   Ian Later	  later@usc.edu
	   Carrie Sun	  carriesu@usc.edu
	  
I. Requirements:
+Overview
Design and Implement syscalls in order to separate user and kernel code. Ensure that user can do nothing to violate security
of data (eg. access physical memory directly, cause OS to crash). After implementing syscalls, we update the Passport office
to be a user program only using this syscalls, and ran two processes of it.

II. Assumptions
In passport office, all customers are created before any finish. Clerks are created before customers so customers don't get
in a void line. 
Address space page table can only accomodate up to 50 thread stacks.


III. Design

#Passport Office#
Lacking dynamic allocation, entities are created and given id's based on order of creation. Because this requires a counter, 
there is a createLock that is acquired by each entity before their creation and released at the beginning of their run function,
to avoid two agents trying to set themselves to the same ID. Also, this assumes that no agent, namely customer, finishes before,
creation of all customers is complete.

The run functions are wrapped in functions that take in no parameters to be easily forked. Run is called on the reference of
the agent array at the returned index of the create function. 

All agents are stored in an array of their types (encapsulated by structs) and are accessed by which line they're in. Since
using structs, there are no getters or setters and data is relatively more unsecure. 

Locks and conditions are stored as in project 1, but here are simply ints that hold reference to the lock and condition table
in exception.cc. 

IV. Implementation
	+Files Modified
  userprog/exception.cc
  userprog/addrspace.cc
  userprog/addrspace.h
  userprog/progtest.cc
  userprog/syscall.h
  tests/start.s
  
	+Files Added
	tests/fork.c
	tests/exec.c
	tests/lockcondition.c
	tests/passport.c
	
	+Data Structures added, and file added to
  Process ProcessTable, KernelLock LockTable, KernelCondition ConditionTable added to Exception.cc
  BitMap* freePageBitMap added to system.h/system.cc
	+Data Structures modified, and the file added to
	
	
	+Functions added and in which file
	userprog/addrspace.h: getId(), setID(int), getNumPages(), setNumPages(int), getBaseDataSize(), CreateStack(int)
	userprog/exception.cc: KernelThread(int), Fork_Syscall(int),Yield_Syscall(), CreateLock_Syscall(int, int), Acquire_Syscall(int), Release_Syscall(int), DestroyLock_Syscall(int), CreateCondition_Syscall(int, int), DestroyCondition_Syscall(int), Wait_Syscall(int, int), Signal_Syscall(int, int), Broadcast_Syscall(int, int), Print_Syscall(int, int, int, int), PrintInt_Syscall(int, int, int, int), Rand_Syscall(), Exec_Thread(), Exec_Syscall(int, int),Exit_Syscall(int)
	userprog/syscall.h: CreateLock(char*, int), DestroyLock(int), Acquire(int), Release(int), CreateCondition(int), DestroyCondition(int), Signal(int, int), Wait(int, int), Broadcast(int, int), Print(char*, int, char*, char*), PrintInt(char*, int, char*, char*),Rand
	
	+Functions modified and in which file
	userprog/exception.cc: ExceptionHandler
	userprog/addrspace.h: AddrSpace::AddrSpace
	
V. Testing
	+How to test
	The part 1 syscalls involving locks and conditions can be tested with the /tests/lockcondition binary. In this test, the possible user inputs for creating, destroying, acquring, waiting, and releasing are all tested. The logic, however, is not tested as throughly as in project 1: the emphasis is on user input.
	Fork tests are in tests/fork. Valid and invalid functions are forked with corresponding output.
	Exec test in test/exec, tests valid filename for execing.
	Passport office test is in test/passport. Can run with a seed, -rs [seed value].
	
	+Test Output
	tests/lockcondition: An assortment of error messages and success messages. Error messages will be out of bounds and invalid index messages, preceeded by "Invalid ..." print statements, and after lock/condition calls with proper input, there will be "... successfully" print messages.
	tests/fork: three different fork calls to test different functions being called. Then, a loop of 40 times forking the same function. The Fork syscall is able to hold up these amounts of threads properly.
	tests/exec: five exec calls. The first two halt. The next is an invalid exec call which should cause an error message. The last two calls simply exec the fork test.
	tests/passport: runs a modified, converted version of passport office from part 1. More information on this will be described below.
	
VI. Discussion
	+Experiment expectation (What is supposed to happen)
	
	
	#Passport Office#
	* The beginning of the simulation is mostly creation of locks and CVs followed by customers getting in lines and clerks waking up
	* Customers and clerks operate in an order discussed in writeup 1. Here lack of senators and penalties though. 
	* The manager periodically outputs earning statements and wakes clerks who've fallen asleep as in P1. 
	* As customers exit, they perform exit syscalls. The simulation should halt with manager ending simulation (printed out).
	* Last manager output should have in cashiers total the number of clerks x $100
	
	+Experiment result. (What actually happened)
	* Passport Office:
		* For unseeded test, the results were as expected. Seeded results pulled up errors in lock acquires and condition waits.
	* Multi Passport Office:
		* 
		
	+Explanation
		
VIII. Miscellaneous:
	
